# -*- coding: utf-8 -*-
"""HW2.5_Spring_25_Student_Version (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unQlzBaCAUYB5s-ajIxHrFIItAoWB-Co

# **PLEASE MAKE YOUR OWN COPY OF THIS NOTEBOOK**

# CIS 5450 Homework 2.5 (Extra Credit)
**Due: Thursday, March 13th, 10:00 PM (or until 4/29 10:00 PM for 10% less extra credit)**

**Total Points: 20**

**This extra credit is completely optional!** You do not have to complete all parts to submit it.

If you want help with this extra credit, visit Jeff's office hours (Thursday 11AM - 1 PM).

Welcome to the Homework 2 extra credit! Here, you'll write more complex SQL queries with DuckDB and take advantage of more advanced SQL features. The following questions do not have as much scaffolding as the regular homeworks: you are expected to do some work figuring out how to structure the query and what SQL features to use.

There is no need to "clean" the data files. **All extra credit questions _can_ and _should_ be answered in a single SQL query!** Do **not** answer the extra credit questions using pandas dataframe manipulations!

**Be sure to click "Copy to Drive" to make sure you're working on your own personal version of the notebook!**

# Part 0: Libraries and Set Up
"""

# Commented out IPython magic to ensure Python compatibility.
# %set_env HW_ID=cis5450_sp25_HW2.5

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install penngrader-client

!pip install pandas
!pip install duckdb
!pip install pandasql
!pip install matplotlib

from penngrader.grader import *
import os
import pandas as pd
import pandasql as ps
import duckdb
from matplotlib import pyplot as plt

# Download the datasets
!wget -nc -O hw25data.tar.xz https://www.dropbox.com/scl/fi/9jeh06gktxvo2fosb5vb6/hw25data.tar.xz?rlkey=04zq1e1hoae1c6nj5ag79pbmb&st=esby9tg1
!tar xfJ hw25data.tar.xz

"""## PennGrader Setup"""

# PLEASE ENSURE YOUR PENN-ID IS ENTERED CORRECTLY.
# IF NOT, THE AUTOGRADER WON'T KNOW WHO TO ASSIGN POINTS TO YOU IN OUR BACKEND
# YOUR PENN-ID GOES HERE AS AN INTEGER
STUDENT_ID = 73619426

# You should also update this to a unique "secret" just for this homework, to
# authenticate this is YOUR submission
SECRET = "...watching silo on appletv...."

"""Leave this cell as-is..."""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile notebook-config.yaml
# 
# grader_api_url: 'https://23whrwph9h.execute-api.us-east-1.amazonaws.com/default/Grader23'
# grader_api_key: 'flfkE736fA6Z8GxMDJe2q8Kfk8UDqjsG3GVqOFOa'

grader = PennGrader('notebook-config.yaml', os.environ['HW_ID'], STUDENT_ID, SECRET)

"""# Part 1: Car Prices (4 Points)

When buying a used car, you’d like for that car to be some reasonable trade off of new (as in years since it was made), low-mileage, and cheap. What you *don’t* want to do is buy a used car that’s strictly worse than some other car on the market.

For example, you would not want to buy a 2020 Honda Accord with 50,000 miles on it for \$20,000 if another 2020 Honda Accord with 50,000 miles is available for \$18,000. However, you would be okay buying a 2022 Honda Accord with 50,000 miles for \$20,000 because it’s newer than the others. You don’t have a preference between year, mileage, and price, you just want to filter out all of the cars that are "bad deals". You also don't care to make comparisons between Brand/Model of car.

| Brand | Model  | Year | Mileage | Price | Worth considering? |
| ----- | ------ | ---- | ------- | ----- | ------------------ |
| Honda | Accord | 2020 | 50000   | 20000 | ❌                 |
| Honda | Accord | 2020 | 50000   | 18000 | ✅                 |
| Honda | Accord | 2022 | 50000   | 20000 | ✅                 |
| Honda | Accord | 2020 | 40000   | 22000 | ✅                 |

Write a single SQL query that finds all such cars that are "worth considering" for which there are no cars of the same brand and model that are strictly better deals in terms of year, mileage, or price. Then, use this query to return the count of such cars per brand, model pair. Intuitively, not all of the cars out there are good deals, so these counts should be smaller than the total number of cars for sale in each brand,  model pair.
"""

# Load the data (10,000 used cars for sale)
car_df = pd.read_csv("car_prices.csv")
car_df

"""Write your solution below as a single SQL query. You may find it useful to work with smaller queries first, and build them up into the final query using CTEs. The resulting dataframe should have 3 columns: `brand`, `model`, `num_deals`. Order of `car_answer_df` doesn't matter as long as all of the car brand/model pairs are present.

Hints:
* You should learn about [subqueries](https://duckdb.org/docs/sql/expressions/subqueries.html#not-exists)

"""

duckdb.register('cars', car_df)

car_answer_df = duckdb.sql("""
WITH valid_deals AS (
  SELECT c1.*
  FROM cars c1
  WHERE NOT EXISTS (
    SELECT 1
    FROM cars c2
    WHERE c1.Brand = c2.Brand
      AND c1.Model = c2.Model
      AND (
        (c2.Year > c1.Year AND c2.Mileage <= c1.Mileage AND c2.Price <= c1.Price) OR
        (c2.Year >= c1.Year AND c2.Mileage < c1.Mileage AND c2.Price <= c1.Price) OR
        (c2.Year >= c1.Year AND c2.Mileage <= c1.Mileage AND c2.Price < c1.Price)
      )
  )
)
SELECT Brand, Model, COUNT(*) AS num_deals
FROM valid_deals
GROUP BY Brand, Model
""").df()

# 4 points
grader.grade(test_case_id = 'test_car_prices', answer = car_answer_df)

"""# Part 2: Stock Prices (8 Points)

Here, we have some stock price data for a single stock ticker (i.e., a single company). When we're looking at a chart of historical prices for a stock, one feature of interest are the "peaks" and "troughs" in the plot of price vs. time.

![](data:image/png;base64,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)

Our definition of "trough" and "peak" may vary depending on the analysis that we do. A very simple definition would be that a trough occurs any time both the preceding and following prices are higher and that a peak occurs any time both the preceding and following prices are lower.

In this question, we'll define a peak to be any time there is no higher price in the _surrounding 14 days_ (inclusive), and that similarly, a trough is any time there is no lower price in the surrounding 14 days.

The dataset contains multiple price columns per-day. **We'll use the "Close" price as the price for the day.**
"""

stock_df = pd.read_csv("stock_prices.csv")
stock_df["Date"] = pd.to_datetime(stock_df["Date"])
stock_df

plt.plot(stock_df["Date"], stock_df["Close"])

"""One thing to note about the above dataframe is that there are days missing! We do not have a stock price for every single consecutive day: there are holes where we have no price for a given day. You'll need to account for this in the query that you write.

Once we have the peaks and troughs, we might be interested in pairing troughs and peaks that occur consecutively, giving us the length of each "rally" in the stock. For each peak, find the immediately preceding trough. It's possible that there might be multiple peaks corresponding to the same trough, so you should take only the latest (newest date) peak corresponding to a particular trough.

Write a single query that returns the trough and peak for each rally in the stock price over time. The resulting dataframe should have 4 columns: `trough_date`, `trough_price`, `peak_date`, `peak_price`. Order of rows in `stock_answer_df` doesn't matter.

Hints:
* You probably need to use [subqueries](https://duckdb.org/docs/sql/expressions/subqueries.html)
* You may want to investigate [lateral joins](https://duckdb.org/docs/sql/query_syntax/from.html#lateral-joins)
* You may find the [RANK window function](https://duckdb.org/docs/sql/functions/window_functions.html) helpful
* You may find it helpful to create debug visualizations with matplotlib (though no visualizations are required for credit)
"""

stock_answer_df = duckdb.sql("""
-- KEEP THIS LINE
SET TIMEZONE='UTC';
-- Write the rest of your query below
WITH stock_data AS (
    SELECT
        Date,
        Close,
        ROW_NUMBER() OVER (ORDER BY Date) AS rn
    FROM stock_df
),
peaks AS (
    SELECT
        Date AS peak_date,
        Close AS peak_price
    FROM stock_data sd1
    WHERE Close = (
        SELECT MAX(Close)
        FROM stock_data sd2
        WHERE sd2.rn BETWEEN sd1.rn - 14 AND sd1.rn + 14
    )
),
troughs AS (
    SELECT
        Date AS trough_date,
        Close AS trough_price
    FROM stock_data sd1
    WHERE Close = (
        SELECT MIN(Close)
        FROM stock_data sd2
        WHERE sd2.rn BETWEEN sd1.rn - 14 AND sd1.rn + 14
    )
),
paired_data AS (
    SELECT
        troughs.trough_date,
        troughs.trough_price,
        peaks.peak_date,
        peaks.peak_price,
        RANK() OVER (PARTITION BY troughs.trough_date ORDER BY peaks.peak_date DESC) AS rank
    FROM troughs
    JOIN peaks ON peaks.peak_date > troughs.trough_date
)
SELECT
    trough_date,
    trough_price,
    peak_date,
    peak_price
FROM paired_data
WHERE rank = 1
ORDER BY trough_date;


""").df()
stock_answer_df

stock_answer_df = duckdb.sql("""
-- KEEP THIS LINE
SET TIMEZONE='UTC';
-- Write the rest of your query below
WITH prices AS (
  SELECT
    Date::DATE AS date,
    Close
  FROM stock_df
),

-- Identify all troughs where the Close price is the minimum in a ±14-day window
troughs AS (
  SELECT p1.date AS trough_date, p1.Close AS trough_price
  FROM prices p1
  WHERE NOT EXISTS (
    SELECT 1 FROM prices p2
    WHERE p2.date BETWEEN p1.date - INTERVAL '14 days' AND p1.date + INTERVAL '14 days'
      AND p2.Close < p1.Close
  )
),

-- Identify all peaks where the Close price is the maximum in a ±14-day window
peaks AS (
  SELECT p1.date AS peak_date, p1.Close AS peak_price
  FROM prices p1
  WHERE NOT EXISTS (
    SELECT 1 FROM prices p2
    WHERE p2.date BETWEEN p1.date - INTERVAL '14 days' AND p1.date + INTERVAL '14 days'
      AND p2.Close > p1.Close
  )
),

-- Pair the peaks with the most recent troughs (one-to-one matching)
peak_trough_pairs AS (
  SELECT
    t.trough_date,
    t.trough_price,
    p.peak_date,
    p.peak_price,
    ROW_NUMBER() OVER (PARTITION BY t.trough_date ORDER BY p.peak_date) AS peak_rank
  FROM troughs t
  JOIN peaks p
    ON p.peak_date > t.trough_date
)

-- Only keep the latest peak for each trough, and ensure proper pairing
SELECT
  trough_date,
  trough_price,
  peak_date,
  peak_price
FROM peak_trough_pairs
WHERE peak_rank = 1
ORDER BY trough_date;
""").df()
stock_answer_df

con = duckdb.connect()
con.register("stock_df", stock_df)

# SQL Query to extract trough-peak pairs
query = """
WITH peaks AS (
    SELECT
        s1.Date AS peak_date,
        s1.Close AS peak_price
    FROM stock_df s1
    WHERE s1.Close = (
        SELECT MAX(s2.Close)
        FROM stock_df s2
        WHERE s2.Date BETWEEN s1.Date - INTERVAL 14 DAY AND s1.Date + INTERVAL 14 DAY
    )
),
troughs AS (
    SELECT
        s1.Date AS trough_date,
        s1.Close AS trough_price
    FROM stock_df s1
    WHERE s1.Close = (
        SELECT MIN(s2.Close)
        FROM stock_df s2
        WHERE s2.Date BETWEEN s1.Date - INTERVAL 14 DAY AND s1.Date + INTERVAL 14 DAY
    )
),
trough_peak_pairs AS (
    SELECT
        t.trough_date,
        t.trough_price,
        p.peak_date,
        p.peak_price,
        RANK() OVER (
            PARTITION BY t.trough_date
            ORDER BY p.peak_date DESC
        ) AS peak_rank
    FROM troughs t
    JOIN peaks p
    ON p.peak_date > t.trough_date
)
SELECT
    trough_date,
    trough_price,
    peak_date,
    peak_price
FROM trough_peak_pairs
WHERE peak_rank = 1
ORDER BY trough_date;
"""

# Execute the query
stock_answer_df = con.execute(query).df()

# Confirm output
print(len(stock_answer_df))  # Should be 32
stock_answer_df.head()

# 8 points
grader.grade(test_case_id = 'test_stock_prices', answer = stock_answer_df)

"""# Part 3: Chess Streaks (8 Points)

Here, we have data from lichess.org, an online platform for playing chess. The table records data about 20,000 chess games played on the platform, including when they were played, the players' usernames, and who won.

We would like to calculate the players who had the longest winning and losing streaks. A streak is defined as a consecutive run of wins (or a consecutive run of losses). Ignore draws (e.g., if a player's 6 game history was Win, Win, Draw, Win, Win, Loss, that player's win streak was length 4).
"""

chess_df = pd.read_csv("chess.csv")
chess_df

"""Write a single query that calculates the players with the top 10 longest streaks. The answer dataframe should contain exactly 10 rows (a mix of win and loss streaks). The dataframe should have 3 columns: `player_id`, `streak_type`, and `streak_length`. `streak_type` should be "winner" or "loser". Order of the rows in `chess_answer_df` doesn't matter.

Hints:
* You may want to compose several [CTEs](https://duckdb.org/docs/sql/query_syntax/with.html) to break the problem into smaller pieces
* You may want to learn about [UNION](https://duckdb.org/docs/sql/query_syntax/setops.html#union)
* Window functions may be helpful, especially [ROW_NUMBER](https://duckdb.org/docs/sql/functions/window_functions.html#row_numberorder-by-ordering) and [LAG](https://duckdb.org/docs/sql/functions/window_functions.html#lagexpr-offset-default-order-by-ordering-ignore-nulls)
"""

chess_answer_df = duckdb.sql("""
WITH base AS (
    SELECT
        created_at,
        white_id AS player_id,
        CASE
            WHEN winner = 'white' THEN 'Win'
            WHEN winner = 'black' THEN 'Loss'
            ELSE 'Draw'
        END AS result
    FROM chess_df
    UNION ALL
    SELECT
        created_at,
        black_id AS player_id,
        CASE
            WHEN winner = 'black' THEN 'Win'
            WHEN winner = 'white' THEN 'Loss'
            ELSE 'Draw'
        END AS result
    FROM chess_df
),
filtered AS (
    SELECT * FROM base WHERE result IN ('Win', 'Loss')
),
with_seq AS (
    SELECT
        player_id,
        result,
        created_at,
        ROW_NUMBER() OVER (PARTITION BY player_id ORDER BY created_at) AS game_seq,
        LAG(result) OVER (PARTITION BY player_id ORDER BY created_at) AS prev_result
    FROM filtered
),
flags AS (
    SELECT
        *,
        CASE
            WHEN result = prev_result THEN 0
            ELSE 1
        END AS streak_start
    FROM with_seq
),
grouped AS (
    SELECT
        player_id,
        result,
        SUM(streak_start) OVER (PARTITION BY player_id ORDER BY game_seq) AS streak_group
    FROM flags
),
streaks AS (
    SELECT
        player_id,
        result,
        streak_group,
        COUNT(*) AS streak_length
    FROM grouped
    GROUP BY player_id, result, streak_group
),
longest_per_player AS (
    SELECT
        player_id,
        CASE WHEN result = 'Win' THEN 'winner' ELSE 'loser' END AS streak_type,
        MAX(streak_length) AS streak_length
    FROM streaks
    GROUP BY player_id, result
),
top10 AS (
    SELECT * FROM longest_per_player
    ORDER BY streak_length DESC
    LIMIT 10
)
SELECT * FROM top10;
""").df()
chess_answer_df

# 8 points
grader.grade(test_case_id = 'test_chess_streaks', answer = chess_answer_df)

"""# HW Submission

Before you submit on Gradescope (you must submit your notebook to receive credit):

1. Restart and Run-All to make sure there's nothing wrong with your notebook
2. Double check that you have the correct PennID (all numbers) in the autograder.
3. Make sure you've run all the PennGrader cells
4. Go to the "File" tab at the top left, and download both the .ipynb and .py files, renaming them as "homework2.ipynb" and "homework2.py" respectively. Upload both files to Gradescope directly!
5. Check your .ipynb file is visible under the code tab. If there is a "large file error" go back and delete all occurances of printing an entire df, and/or make your figure sizes smaller, then resubmit. Then confirm the notebook preview is now visible in your Gradescope submission.

You MUST verify that the autograder finishes running and gives you your expected score (not a 0).

Please contact Jeff (jefftao@seas.upenn.edu, OH Thursday 11 AM - 1 PM) if you have any issues submitting, but otherwise best of luck! Congrats on finishing the HW.
"""